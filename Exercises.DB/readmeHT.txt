Αρχειο Στατικου Κατακερματισμου:

.h Αρχεια :
 
Στο αρχειο record.h δεν εκανα καμια αλλαγη.

Οσον αφορα το ht_table.h ορισα δυο structs.
 
1)Το struct HT_info το οποιο κραταει την πληροφορια που βρισκεται στο block 0. Σαυτο το struct κραταω τον αναγνωριστικο αριθμο του αρχειου (fileDesc), τον αριθμο των buckets 
(numBuckets), ενα δεικτη σε int (int* hashTable) που μας δειχνει για καθε bucket τον αριθμο του block που εχει κανει allocate (χρησιμοποιησα ως σχεδιαστικη τεχνικη εδω 
το bucket να μην δειχνει σε block απευθειας αλλα σε εναν αριθμο, δηλαδη αν το bucket 3 δειχνει στο block 7 εχουμε hashTable[3]=7) και κραταω και το maximum αριθμο εγγραφων 
που μπορουν να χωρανε σε ενα block (size).

2)Το struct HT_block_info το οποιο κραταει το τρεχον πληθος εγγραφων στο συγκεκριμενο block (recordCount) και εναν ακεραιο που αντιπροσωπευει το επομενο block (nextBlock). 
Η λογικη του nextBlock ειναι η ιδια με το hashTable, αντι να εχω δεικτη σε block κραταω τον αριθμο του block. Επισης αυτη η δομη αποθηκευεται στο τελος καθε block οπως 
εχει αναφερθει και στο μαθημα. Αν το nextBlock = -1 τοτε σημαινει οτι δεν εχει γινει ακομα allocate το επομενο block επειδη δεν εχει γεμισει το τρεχον.

.c Αρχεια :

1)ht_table.c

Παιρνουμε τις συναρτησεις μια μια και εξηγω την λειτουργικοτητα τους :

hashFunction -> Μας δινει το bucket στο οποιο θα μπει η εγγραφη με βαση το id της. Μας αρκει απλα να επιστρεψουμε το id%numBuckets. 

HT_CreateFile -> Δημιουργουμε το αρχειο, το ανοιγουμε και κανουμε allocate ενα block, ετσι ωστε να γραψουμε σε αυτο την πληροφορια HT_info. Ολοι οι καδοι αρχικοποιουνται 
στο -1 ετσι ωστε να γνωριζουμε οτι ειναι αδειοι. (Σε αυτο το σημειο να πουμε οτι το allocate γινεται κατα την εισοδο των εγγραφων και οχι κατα την αρχικοποιηση των δομων)
Μετα κλεινουμε το αρχειο για να το ξανανοιξουμε με την HT_OpenFile.

HT_OpenFile -> Απλα ανοιγει το αρχειο με ονομα fileName, διαβαζει την πληροφορια που υπαρχει στο block 0 και την επιστρεφει.

HT_CloseFile -> Αποδεσμευει τις δομες και κλεινει το αρχειο.

HT_InsertEntry ->  Αρχικα βρισκουμε με την συναρτηση κατακερματισμου μας σε ποιον καδο θα μπει η εγγραφη. Αφου το κανουμε αυτο παρατηρουμε 3 περιπτωσεις. 
α) Να μην εχουμε κανει ακομα allocate καποιο block για αυτο τον καδο. Τοτε πρεπει να κανουμε allocate και να περασουμε με memcpy την εγγραφη μας. Ενημερωνουμε 
επισης το ht_block_info και το γραφουμε και αυτο με memcpy στο τελος του block και κανουμε dirty και unpin το block. 
β) Αν εχω κανει allocate ενα block και χωρανε ακομα εγγραφες σε αυτο το block. Τοτε απλα γραφω με memcpy στο block την εγγραφη και ενημερωνω τις καταλληλες δομες.
γ) Αν εχω κανει allocate αλλα εχει γεμισει το block. Τοτε πρεπει να κανω allocate ενα καινουργιο block και να γραψω την εγγραφη σε αυτο. Επισης για να μην 
χρειαστει ,οταν πρεπει να ξαναβαλουμε εγγραφη σε αυτον τον καδο ,να περασουμε παλι απο το γεματο block κανουμε το hashTable[i] να δειχνει στο καινουργιο block
και το nextBlock να μας δειχνει στο γεματο block. Ετσι γλυτωνουμε πολυ χρονο.
Στο τελος επιστρεφουμε το blockId που ειναι ο αριθμος του block που μπηκε η εγγραφη.

HT_GetAllEntries -> Αρχικα κανουμε cast το void* σε int για να παρουμε το id. Αφου παρουμε το hash, ξεκιναμε ενα loop για τα block που υπαρχουν στον συγκεκριμενο
καδο, το οποιο τελειωνει οταν βρει το blockNumber == -1. Μετα αρχιζουμε να ψαχνουμε σε καθε block αν υπαρχει το id που ψαχνουμε. Οταν το βρουμε επιστρεφουμε 
τα block που διασχισαμε, αλλιως επιστρεφουμε -1 που σημαινει οτι δεν υπαρχει το id.

2)ht_main.c

Στην main πειραματιστηκαμε με πολλα αρχεια. Εχουμε βαλλει αρκετα print, ωστε να φαινεται η ροη του προγραμματος. Κατα την δημιουργια ενος record μπαινει απευθειας στο
αρχειο. Τελος τρεχουμε την HT_GetAllEntries για διαφορα id και την hashStatistics για να δουμε τα στατιστικα.