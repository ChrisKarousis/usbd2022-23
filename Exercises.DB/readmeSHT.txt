Αρχεια Δευτερευοντος Κατακερματισμου:

.h Αρχεια :

Στο αρχειο record.h δεν εκανα καμια αλλαγη.

Οσον αφορα το sht_table.h εφτιαξα 3 structs.

1) Tο struct SHT_record κραταει το πεδιο name του record (name), το block στο οποιο βρισκεται η εγγραφη στο πρωτευον αρχειο κατακερματισμου
(blockId) και το τι μορφη εχει αυτο το record (record). Εδω χρησιμοποιησαμε ως σχεδιαστικη τεχνικη να μην αποθηκευουμε ολοκληρο το block αλλα μονο τον 
αριθμο του block. Επισης το πεδιο record παροτι δεν το αξιοποιουμε καπως το βαλαμε για ομοιομορφια του κωδικα, αφου υπαρχει και στο record.h που 
μας δωθηκε.

2) Το struct SHT_info το οποιο κραταει την πληροφορια που βρισκεται στο block 0. Σαυτο το struct κραταω τον αναγνωριστικο αριθμο του αρχειου (fileDesc), τον αριθμο των buckets 
(numBuckets), ενα δεικτη σε int (int* shashTable) που μας δειχνει για καθε bucket τον αριθμο του block που εχει κανει allocate (χρησιμοποιησα ως σχεδιαστικη τεχνικη εδω 
το bucket να μην δειχνει σε block απευθειας αλλα σε εναν αριθμο, δηλαδη αν το bucket 3 δειχνει στο block 7 εχουμε hashTable[3]=7) και κραταω το maximum αριθμο εγγραφων 
που μπορουν να χωρανε σε ενα block (size) και το fileDesc του πρωτευοντος ευρετηριου (primary).

3)Το struct SHT_block_info το οποιο κραταει το τρεχον πληθος εγγραφων στο συγκεκριμενο block (recordCount) και εναν ακεραιο που αντιπροσωπευει το επομενο block (nextBlock). 
Η λογικη του nextBlock ειναι η ιδια με το shashTable, αντι να εχω δεικτη σε block κραταω τον αριθμο του block. Επισης αυτη η δομη αποθηκευεται στο τελος καθε block οπως 
εχει αναφερθει και στο μαθημα. Αν το nextBlock = -1 τοτε σημαινει οτι δεν εχει γινει ακομα allocate το επομενο block επειδη δεν εχει γεμισει το τρεχον.

.c Αρχεια :

1) sht_table.c

Παιρνουμε τις συναρτησεις μια μια και εξηγω την λειτουργικοτητα τους :

shtHashFunction -> Παιρνουμε το πρωτο γραμμα του name, το αφαιρουμε με το 'Α' (γιατι το πρωτο γραμμα της λεξης ειναι σε κεφαλαια) και μετα το κανουμε mod με το numBuckets.
Καποια ονοματα θα μπουν στο ιδιο bucket, παρολο που δεν ειναι ιδια, αλλα δεν μας ενοχλει καπου αυτο.

Οι συναρτησεις SHT_CreateSecondaryIndex, SHT_OpenSecondaryIndex και SHT_CloseSecondaryIndex εχουν παρομοια λειτουργικοτητα με τις αντιστοιχες στα αρχεια στατικου
κατακερματισμου με την μονη διαφορα οτι οταν κανουμε create το αρχειο πρεπει να κανουμε open και το πρωτευον αρχειο κατακερματισμου ετσι ωστε να αποθηκευσουμε το 
fileDesc του.

SHT_SecondaryInsertEntry -> Ακριβως η ιδια λειτουργικοτητα με τα ht.

SHT_SecondaryGetAllEntries -> Σαυτη την συναρτηση βρισκουμε ολες τις εγγραφες που εχουν το name που δινουμε. Για να μην μας εκτυπωνει πολλες φορες τα ιδια ονοματα οταν 
υπαρχουν στο ιδιο block εχουμε τον πινακα visited[blockNumber][i] ο οποιος αρχικοποιειται με 0 και οταν βρισκουμε μια εγγραφη το θετουμε σε 1. Επειτα αυτο που κανουμε 
ειναι να βρισκουμε με την shtHashFunction το μπλοκ στο οποιο υπαρχει το συγκεκριμενο ονομα, μετα παιρνουμε το blockId το οποιο μας υποδεικνυει που υπαρχει αυτο το ονομα 
στο πρωτευον ευρετηριο και κανουμε αλλη μια λουπα στο block του πρωτευοντος ευρετηριου για να βρουμε τις εγγραφες που ψαχνουμε.

2) sht_main.c

Η main ειναι παρομοια με την δοσμενη, με την διαφορα οτι εχουμε χρησιμοποιησει την hashStatistics.
